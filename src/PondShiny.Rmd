---
title: "Cape Cod Pond Analyses"
date: "2024-07-19"
runtime: shiny
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_knit$set(root.dir = "~/Desktop/Repos/CapeCodPonds2023")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r include = FALSE}
### Load packages

library(tidyverse)
library(gsw)
library(trend)
library(egg)
library(DT)
library(pals)
library(sf)
library(rkt)
```

```{r include = FALSE}
### Load data

setwd("~/Desktop/Repos/CapeCodPonds2023")

#ponds_full <- read.csv("data/072523_CC_AllPonds_WQ.csv", header = TRUE) %>%
#ponds_full <- read.csv("data/09132023_CC_AllPonds_WQ.csv", header = TRUE) %>%
#ponds_full <- read.csv("data/11032023_CC_AllPonds_WQ.csv", header = TRUE) %>%
#ponds_full <- read.csv("data/12142023_CC_AllPonds_WQ.csv", header = TRUE) %>%
ponds_full <- read.delim("data/03182024_CC_AllPonds_WQ.txt", header = TRUE) %>%
  
  # remove non-data rows
  filter(Station.name != "" & Station.name != " ")
```

```{r include = FALSE}
ponds <- ponds_full

# remove WISKI-designated outliers
for(qc in colnames(ponds %>% dplyr::select(contains("Quality.code")))) {
  index <- match(qc, colnames(ponds))
  ponds[[index - 1]] <- if_else(ponds[[qc]] == "Pond - Outlier",
                               "",
                               ponds[[index - 1]],
                               missing = ponds[[index - 1]])
}

ponds <- ponds %>%
  # merge same-parameter columns & reorganize data frame
  unite(Alk, Alkalinity...ALK, Alkalinity...ALK.1, sep = "") %>%
  unite(Chla, Chlorophyll...CHLA, Chlorophyll...CHLA.1, sep = "") %>%
  unite(DO, Dissolved.Oxygen...Reported...DO, Dissolved.Oxygen...Reported...DO.1,
        Dissolved.Oxygen...Reported...DO.2, sep = "") %>%
  unite(DO_sat, Dissolved.Oxygen.Saturation...Reported...DO_SAT,
        Dissolved.Oxygen.Saturation...Reported...DO_SAT.1, sep = "") %>%
  unite(pH, pH...PH, pH...PH.1, pH...PH.2, sep = "") %>%
  unite(Phaeo, Phaeophytin...PHAEO, Phaeophytin...PHAEO.1, sep = "") %>%
  unite(Sal, Salinity...SAL, Salinity...SAL.1, sep = "") %>%
  unite(Secchi, Secchi.Depth...SECCHI, Secchi.Depth...SECCHI.1,
        Secchi.Depth...SECCHI.2, sep = "") %>%
  unite(TN_uM, Total.Nitrogen...Reported...TN, Total.Nitrogen...Reported...TN.1, sep = "") %>%
  unite(TP_uM, Total.Phosphorus...TP, Total.Phosphorus...TP.1, sep = "") %>%
  unite(Temp, Water.Temperature...TEMP, Water.Temperature...TEMP.1,
        Water.Temperature...TEMP.2, sep = "") %>%
  
  # split long/lat coordinates
  separate_wider_delim(Long.lat.coordinates, " / ", names = c("Long", "Lat"), too_few = "align_start") %>%
  
  # rename columns with redundant headers
  rename(CTI_TP = Carlson.Trophic.Index...Total.Phosphorus.based...CTI_TP,
         CTI_Chlorophyll = Carlson.Trophic.Index...Chlorophyll.a.based...CTI_CHLA,
         CTI_Secchi = Carlson.Trophic.Index...Secchi.Depth.Based...CTI_SD,
         Total.Depth = Total.Depth...DTB,
         TP = Total.Phosphorus...micrograms.per.liter...TP_ugL) %>%
  
  # reorder columns
  relocate(Total.Depth, .before = Depth) %>%
  relocate(Secchi, .after = Depth) %>%
  relocate(Temp, .after = Secchi) %>%
  relocate(DO, .after = Temp) %>%
  relocate(DO_sat, .after = DO) %>%
  relocate(Alk, .after = DO_sat) %>%
  relocate(TP, .after = Alk) %>%
  relocate(Chla, .after = TP) %>%
  relocate(TN_uM, .after = Chla) %>%
  relocate(TP_uM, .after = TN_uM) %>%
  
  # extract date, month, year from date-time column & create new column
  mutate(Date = str_extract(Date.Time..sampling., "\\d+/\\d+/\\d+"),
         Time = str_extract(Date.Time..sampling., "\\d{1,2}:\\d{2}"),
         Month = str_extract(Date, "\\d{1,2}(?=/)"),
         #Year = paste("20", str_extract(Date, "(?<=\\d{1,2}/\\d{1,2}/)\\d+"), sep = ""),
         ## use this^ if WISKI output has M/D/YY format; use line below if output has M/D/YYYY format
         Year = str_extract(Date, "(?<=\\d{1,2}/\\d{1,2}/)\\d+"),
         Year_frac = as.numeric(Year) + as.numeric(Month)/12) %>%
  
  # note last year sampled for later reference
  group_by(Station.name) %>%
  mutate(Last_year = max(Year)) %>%
  ungroup() %>%
  
  # prepare columns for reordering ponds in dropdown menu
  mutate(Town = str_extract(Station.name, "[A-Z]{2}")) %>%
  mutate(Station = str_extract(Station.name, ".+(?= /)")) %>%
  mutate(Station.name = paste0(Town, " / ", Station, " (", Station.number, ")"))

# convert all empty cells to NA
ponds[ponds == ""] <- NA

# fix non-numeric characters

# nm <- ponds %>%
#   select(-contains("Quality.code"), -Sample.number, -Depth.Designation) %>%
#   select(c(which(colnames(.) == "Total.Depth") : (which(colnames(.) == "Date") - 1))) %>%
#   filter(if_any(everything(), ~ str_detect(., "[:alpha:]|<|>")))
# 
# sort(unique(unlist(nm)[!is.na(str_extract(unlist(nm), "[:alpha:]|<|>"))]))   ### use this to identify problem vals

ponds[ponds == "< 0.05"] <- "0"
ponds[ponds == "< 0.10"] <- "0"
ponds[ponds == "< 1.00"] <- "1.00"
ponds[ponds == "< 1.50"] <- "1.50"
ponds[ponds == "> 15.50"] <- "15.50"

ponds[ponds == "BDL 0.00"] <- "0"
ponds[ponds == "<MDL 0.00"] <- NA
ponds[ponds == "n.m. 0.00"] <- NA
ponds[ponds == "ND 0.00"] <- NA

ponds[ponds == "n.m. 0.03"] <- "0.03"
ponds[ponds == "n.m. 1.37"] <- "1.37"
ponds[ponds == "n.m. 6.83"] <- "6.83"
ponds[ponds == "n.m. 13.96"] <- "13.96"
ponds[ponds == "n.m. 13.98"] <- "13.98"
ponds[ponds == "n.m. 19.90"] <- "19.90"
ponds[ponds == "n.m. 30.81"] <- "30.81"

# convert all numerical cols to numeric
is_all_numeric <- function(x) {
  !any(is.na(suppressWarnings(as.numeric(na.omit(x))))) & is.character(x)
}
not_all_na <- function(x) any(!is.na(x))
ponds <- ponds %>% 
  mutate_if(is_all_numeric, as.numeric) %>%
  dplyr::select(where(not_all_na))

#str(ponds)

# fix inappropriately negative characters

# neg <- ponds %>%
#   select(where(is.numeric), -contains(c("Long", "CTI", "ORP"))) %>%
#   filter(if_any(everything(), ~ str_detect(., "-")))
# 
# sort(unique(unlist(neg)[!is.na(str_extract(unlist(neg), "-"))]))

ponds[ponds == -0.04] <- 0.04
ponds[ponds == -0.15] <- 0.15
ponds[ponds == -0.3] <- 0.3

# fix erroneous values
ponds$DO[ponds$Station.name == "HA-353-01 / Hinckleys Pond" &
         ponds$DO == 0.84] <- NA
ponds$DO_sat[ponds$Station.name == "HA-353-01 / Hinckleys Pond" &
             ponds$DO_sat == 121.12] <- NA
ponds$DO[ponds$Station.name == "HA / Seymour Pond (HA-306-01)" &
         ponds$DO == 0 & ponds$Depth == 0.05] <- NA

# remove 2023 Secchi depths (measured using different protocol; not comparable)
ponds$Secchi <- ifelse(ponds$Year == 2023, NA, ponds$Secchi)

# copy Secchi values to all rows (esp. from rows with NA depth)
for(i in 1:nrow(ponds)) {
  if(!is.na(ponds$Secchi[i])) {
    ponds$Secchi[ponds$Station.name == ponds$Station.name[i] & ponds$Date == ponds$Date[i]] <-
      mean(ponds$Secchi[ponds$Station.name == ponds$Station.name[i] & ponds$Date == ponds$Date[i]], na.rm = TRUE)
  }
}

ponds <- ponds %>%
  group_by(Station.name, Date) %>%
  mutate(Secchi = mean(Secchi, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(Secchi = ifelse(is.nan(Secchi), NA, Secchi))
```

```{r include = FALSE}
# calculate DO saturation values (*in future should come from WISKI)
for(i in 1:nrow(ponds)) {
  if(is.na(ponds$DO_sat[i])) {
    rho <- gsw_rho(0, ponds$Temp[i], ponds$Depth[i]) # kg/m^3
    ponds$DO_sat[i] <- ponds$DO[i] / 31.999 / rho * 10^6 /
                        gsw_O2sol(0, ponds$Temp[i], ponds$Depth[i], ponds$Long[i], ponds$Lat[i]) * 100
  }
  if(is.na(ponds$DO[i])) {
    rho <- gsw_rho(0, ponds$Temp[i], ponds$Depth[i]) # kg/m^3
    ponds$DO[i] <- gsw_O2sol(0, ponds$Temp[i], ponds$Depth[i], ponds$Long[i], ponds$Lat[i]) / 100 *
                    ponds$DO_sat[i] * 31.999 * rho / 10^6
  }
  if(!is.na(ponds$DO[i]) & !is.na(ponds$DO_sat[i]) &
     ponds$DO[i] == 0 & ponds$DO_sat[i] > 0) {
    rho <- gsw_rho(0, ponds$Temp[i], ponds$Depth[i]) # kg/m^3
    ponds$DO[i] <- gsw_O2sol(0, ponds$Temp[i], ponds$Depth[i], ponds$Long[i], ponds$Lat[i]) / 100 *
                    ponds$DO_sat[i] * 31.999 * rho / 10^6
  }
}

#mg/L to um/kg
#mg/L * 1000L/m^3 = mg/m^3 * 1g/1000mg = g/m^3 * 1mol/31.999g = mol/m^3 * 1/rho m^3/kg = mol/kg * 1,000,000 umol/mol


# convert uM to ug/L
ponds$TN <- ponds$TN_uM * 14.0067
ponds$TP <- ifelse(!is.na(ponds$TP), ponds$TP, ponds$TP_uM * 30.973762)

ponds <- ponds %>%
  relocate(TN, .before = TP)

# uM = umol/L * mol/10^6umol = mol/10^6L * Xg/mol = g/10^6L * 10^6ug/g = ug/L
```

```{r include = FALSE}
# calculate MLDs
ponds$MLD <- NA
ponds$Max.Depth <- NA

allPonds <- unique(ponds$Station.name)

for(pond in allPonds) {
  onePond <- ponds[ponds$Station.name == pond, ] %>%
    arrange(Date, Depth)
  
  # create full-depth column
  ponds$Max.Depth[ponds$Station.name == pond] <- max(onePond$Depth, na.rm = TRUE)
  
  if(max(onePond$Depth, na.rm = TRUE) < 5) {   # pond must be deeper than 5m to have a MLD
    next
  }
  
  for(d in unique(onePond$Date)) {
    oneDate <- onePond[onePond$Date == d &
                       (onePond$Month == 8 |      # delete this + next line to evaluate MLD in all months
                        onePond$Month == 9) &     # note that doing this^^ will mess up MLD trend plots
                       !is.na(onePond$Depth), ]
    if(sum(!is.na(oneDate$Temp)) < 2 | n_distinct(oneDate$Depth[oneDate$Depth >= 1]) < 2) {
      next
    }
    for(i in 1:(n_distinct(oneDate$Depth) - 1)) {
      if(is.na(oneDate$Temp[i]) | oneDate$Depth[i] < 1) {
        next
      }
      j <- i + 1
      while(j < n_distinct(oneDate$Depth)) {
        if(!is.na(oneDate$Temp[j])) {
          break
        } else {
          j <- j + 1
        }
      }
      if(is.na(oneDate$Temp[j])) {
        next
      } else {
        depth_diff <- oneDate$Depth[j] - oneDate$Depth[i]
        temp_diff <- oneDate$Temp[j] - oneDate$Temp[i]
        delta_temp <- temp_diff / depth_diff
        if(delta_temp < -1) {
          ponds$MLD[ponds$Station.name == pond &
                    ponds$Date == d &
                    (ponds$Month == 8 |
                     ponds$Month == 9)] <- oneDate$Depth[i]
          break
        }
      }
      if(delta_temp >= -1 & oneDate$Depth[j] >= 0.75 * max(onePond$Depth, na.rm = TRUE)) {
        ponds$MLD[ponds$Station.name == pond &
                  ponds$Date == d &
                  (ponds$Month == 8 |
                   ponds$Month == 9)] <- oneDate$Depth[j]
      }  ### moved this inside green brackets; see if this fixes Mashpee Lake problem
    }
  }
}

ponds <- ponds %>%
  relocate(Max.Depth, .before = Depth) %>%
  relocate(MLD, .before = Temp)
```

```{r include = FALSE}
## Fish space calcs

# calculate MLDs using 1st derivative
ponds$hypo <- NA
ponds$DO.4 <- NA
ponds$VerticalFishSpace <- NA
ponds$VolumetricFishSpace <- NA

allPonds <- unique(ponds$Station.name)

for(pond in allPonds) {
  # comment this out to evaluate MLD in all months (will mess up plots)
  if(sum(ponds$Month[ponds$Station.name == pond] == 8 |
         ponds$Month[ponds$Station.name == pond] == 9) == 0) {
    next
  }
  
  onePond <- ponds[ponds$Station.name == pond, ] %>%
    filter(Month == 8 | Month == 9) %>%
    arrange(Date, Depth)
  
  for(d in unique(onePond$Date)) {
    if(sum(!is.na(onePond$MLD[onePond$Date == d]) &
       # skip fully mixed ponds
       onePond$MLD[onePond$Date == d] <= 0.75 * onePond$Max.Depth[1],
       na.rm = TRUE) == 0) {
      next
    }
    
    oneDate <- onePond[onePond$Date == d &
                       !is.na(onePond$Depth), ] %>%
      arrange(Depth)
    if(sum(!is.na(oneDate$Temp)) < 2 | n_distinct(oneDate$Depth[oneDate$Depth >= 1]) < 2) {
      next
    }
    # interpolate missing values
    for(i in 2:(nrow(oneDate) - 1)) {
      if(sum(!is.na(oneDate$Temp) > 0) & is.na(oneDate$Temp[i])) {
        oneDate$Temp[i] <- approx(x = oneDate$Depth,
                                  y = oneDate$Temp,
                                  xout = oneDate$Depth[i])[[2]]
      }
      if(sum(!is.na(oneDate$DO) > 0) & is.na(oneDate$DO[i])) {
        oneDate$DO[i] <- approx(x = oneDate$Depth,
                                y = oneDate$DO,
                                xout = oneDate$Depth[i])[[2]]
      }
    }
    index <- tail(which((oneDate$Temp - lag(oneDate$Temp)) /
                          (oneDate$Depth - lag(oneDate$Depth)) ==
                        min((oneDate$Temp - lag(oneDate$Temp)) /
                              (oneDate$Depth - lag(oneDate$Depth)),
                            na.rm = TRUE)),
                  1)
    # if(length(index) > 1) {
    #   print(paste(pond, "--", d))
    # }
    ponds$hypo[ponds$Station.name == pond & ponds$Date == d] <- oneDate$Depth[index]
    
    if(length(which(oneDate$DO >= 4)) > 0) {
      if(length(which(oneDate$DO < 4)) > 0) {
        ponds$DO.4[ponds$Station.name == pond & ponds$Date == d] <-
          approx(x = oneDate$DO, y = oneDate$Depth, xout = 4)[[2]]
      } else {
        ponds$DO.4[ponds$Station.name == pond & ponds$Date == d] <-
          max(oneDate$Depth)
      }
    }
  }
}

ponds <- ponds %>%
  mutate(VerticalFishSpace = ifelse(DO.4 - hypo > 0, DO.4 - hypo, 0)) %>%
  relocate(VerticalFishSpace, .after = MLD)
```

```{r include = FALSE}
# match ponds to metadata
setwd("~/Desktop/Repos/CapeCodPonds2023")

chars <- read.csv("data/PondCharacteristics.csv") %>%
  mutate(across(where(is.character), ~ na_if(., "#N/A")))

ponds$Size <- NA
ponds$Lens <- NA
ponds$PercentDeveloped <- NA
ponds$Char.Depth.ft <- NA

for(i in 1:nrow(ponds)) {
  ID <- str_extract(ponds$Station.number[i], "[A-Z]{2}-\\d+")
  if(length(chars$Acres[chars$CCC_GIS_ID == ID]) > 0) {
    ponds$Size[i] <- as.numeric(chars$Acres[chars$CCC_GIS_ID == ID])
    ponds$Lens[i] <- chars$Aquifer.Lens[chars$CCC_GIS_ID == ID]
    ponds$PercentDeveloped[i] <- chars$X..100ft.buffer.developed[chars$CCC_GIS_ID == ID]
    ponds$Char.Depth.ft[i] <- as.numeric(chars$Final.Depth[chars$CCC_GIS_ID == ID])
  }
}

ponds <- ponds %>%
  mutate(Char.Depth = Char.Depth.ft * 0.3048,
         VolumetricFishSpace = VerticalFishSpace * Size * 4046.86) %>%
  relocate(Char.Depth, .before = Max.Depth) %>%
  relocate(VolumetricFishSpace, .after = VerticalFishSpace)

ponds <- ponds %>%
  mutate(DepthClass = case_when(Max.Depth <= 3 ~ "Shallow",
                                Max.Depth > 3 ~ "Deep"))

ponds$SurfaceAreaClass <- NA

# ponds_grouped <- ponds %>%
#   group_by(Station.name) %>%
#   summarize(Size = Size[1])
# 
# quantile(ponds_grouped$Size, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)

ponds$SurfaceAreaClass <- case_when(ponds$Size <= 5.743542 ~ "Very Small",
                                    ponds$Size <= 12.315432 ~ "Small",
                                    ponds$Size <= 32.563650 ~ "Medium",
                                    ponds$Size > 32.563650 ~ "Large")

ponds$PercentDeveloped <- as.numeric(str_extract(ponds$PercentDeveloped, ".*(?=%)"))

# ponds_grouped <- ponds %>%
#   group_by(Station.name) %>%
#   summarize(PercentDeveloped = PercentDeveloped[1])
# 
# quantile(ponds_grouped$PercentDeveloped, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)

ponds <- ponds %>%
  mutate(DevelopmentClass = case_when(ponds$PercentDeveloped <= 5.00 ~ "Very Low",
                                      ponds$PercentDeveloped <= 13.00 ~ "Low",
                                      ponds$PercentDeveloped <= 23.25 ~ "Medium",
                                      ponds$PercentDeveloped > 23.25 ~ "High"))
```

```{r include = FALSE}
setwd("~/Desktop/Repos/CapeCodPonds2023")

focal_ponds <- ponds %>%
  filter(Month == 8 | Month == 9)

pondName <- sort(unique(focal_ponds$Station.name))

ponds$Temp_flag <- NA
ponds$DO_flag <- NA

clim_all <- data.frame(matrix(ncol = 6, nrow = 2500))
colnames(clim_all) <- c("Station.name", "Depth", "Temp", "Temp_sd", "DO", "DO_sd")

for(pond in pondName) {
  onePond <- ponds %>%
    filter(Month == 8 | Month == 9) %>%
    filter(Station.name == pond,
           !is.na(Depth))
  if(nrow(onePond) == 0) {
    next
  }
  onePond$Depth[onePond$Depth == 0] <- 0.01
  clim <- data.frame(matrix(ncol = 5, nrow = length(1:ceiling(max(onePond$Depth)))))
  colnames(clim) <- c("Depth", "Temp", "Temp_sd", "DO", "DO_sd")
  for(param in c("Temp", "DO")) {
    param_sd <- paste0(param, "_sd")
    
    clim$Depth[1:length(1:ceiling(max(onePond$Depth)))] <- 1:ceiling(max(onePond$Depth))
    clim.v <- rep(NA, nrow(clim))
    clim.v2 <- rep(NA, nrow(clim))
    for(i in 1:length(clim$Depth)) {
      clim1 <- mean(onePond[[param]][onePond$Depth >= i - 0.99 & onePond$Depth <= i],
                    na.rm = TRUE)
      clim.v[clim$Depth == i] <- clim1
      clim2 <- sd(onePond[[param]][onePond$Depth >= i - 0.99 & onePond$Depth <= i], na.rm = TRUE)
      clim.v2[clim$Depth == i] <- clim2
    }
    clim[[param]][1:length(clim.v)] <- clim.v
    clim[[param_sd]][1:length(clim.v2)] <- clim.v2
    clim[[param_sd]] <- ifelse(is.na(clim[[param_sd]]), 0, clim[[param_sd]])
    flag_name <- paste0(param, "_flag")
    for(j in 1:nrow(onePond)) {
      depth <- ceiling(onePond$Depth[j])
      m <- clim[[param]][clim$Depth == depth]
      sd <- clim[[param_sd]][clim$Depth == depth]
      if(is.na(onePond[[param]][j])) {
        onePond[[flag_name]][j] <- 4
      } else if(onePond[[param]][j] >= m - 3*sd & onePond[[param]][j] <= m + 3*sd) {
        onePond[[flag_name]][j] <- 2
      } else {
        onePond[[flag_name]][j] <- 3
      }
    }
    ponds[[flag_name]][ponds$Station.name == pond & !is.na(ponds$Depth) & (ponds$Month == 8 | ponds$Month == 9)] <-
      onePond[[flag_name]]
    
    # repeat the above calcs now with outliers removed
    for(i in 1:length(clim$Depth)) {
      clim1 <- mean(onePond[[param]][onePond$Depth >= i - 0.99 & onePond$Depth <= i &
                                       onePond[[flag_name]] == 2], na.rm = TRUE)
      clim.v[clim$Depth == i] <- clim1
      clim2 <- sd(onePond[[param]][onePond$Depth >= i - 0.99 & onePond$Depth <= i &
                                       onePond[[flag_name]] == 2], na.rm = TRUE)
      clim.v2[clim$Depth == i] <- clim2
    }
    clim[[param]][1:length(clim.v)] <- clim.v
    clim[[param_sd]][1:length(clim.v2)] <- clim.v2
    clim[[param_sd]] <- ifelse(is.na(clim[[param_sd]]), 0, clim[[param_sd]])
  }
  clim_all[sum(!is.na(clim_all$Station.name)) + 1:nrow(clim), 2:6] <- clim
  clim_all$Station.name[sum(!is.na(clim_all$Station.name)) + 1:nrow(clim)] <- pond
}

clim_all <- clim_all %>%
  filter(!is.na(Station.name))

ponds$Temp_anom <- NA
ponds$DO_anom <- NA

for(i in 1:nrow(ponds)) {
  if(ponds$Month[i] != 8 & ponds$Month[i] != 9) {
    next
  }
  pond <- ponds$Station.name[i]
  if(is.na(ponds$Depth)[i]) {
    next
  }
  if(ponds$Depth[i] == 0) {
    a <- 0.01
    b <- 1
  } else if(ponds$Depth[i] %% 1 != 0){
    a <- floor(ponds$Depth[i]) + 0.01
    b <- ceiling(ponds$Depth[i])
  } else {
    a <- ponds$Depth[i]
    b <- ponds$Depth[i]
  }
  ponds$Temp_anom[i] <- ponds$Temp[i] - clim_all$Temp[clim_all$Station.name == pond &
                                                      clim_all$Depth >= a &
                                                      clim_all$Depth <= b]
  ponds$DO_anom[i] <- ponds$DO[i] - clim_all$DO[clim_all$Station.name == pond &
                                                clim_all$Depth >= a &
                                                clim_all$Depth <= b]
}

# load surface-only data
allSurface <- read.csv("data/AllPonds_Surface.csv") %>%
  #mutate(across(where(is.character), ~ na_if(., "#N/A"))) %>%
  mutate(DepthClass = factor(DepthClass, levels = c("Shallow", "Deep"))) %>%
  mutate(DevelopmentClass = factor(DevelopmentClass, levels = c("Very Low", "Low", "Medium", "High", "Very High"))) %>%
  mutate(SurfaceAreaClass = factor(SurfaceAreaClass, levels = c("Very Small", "Small", "Medium", "Large")))

allSurface$Temp_anom <- NA
allSurface$DO_anom <- NA

# copy over surface anomalies
for(i in 1:nrow(allSurface)) {
  pond <- allSurface$Station.name[i]
  allSurface$Temp_anom[i] <-
    allSurface$Temp[i] - clim_all$Temp[clim_all$Station.name == pond &
                                         clim_all$Depth == min(clim_all$Depth[clim_all$Station.name == pond])]
  allSurface$DO_anom[i] <-
    allSurface$DO[i] - clim_all$DO[clim_all$Station.name == pond &
                                     clim_all$Depth == min(clim_all$Depth[clim_all$Station.name == pond])]
}

# load bottom-only data
allBottom <- read.csv("data/AllPonds_Bottom.csv") %>%
  #mutate(across(where(is.character), ~ na_if(., "#N/A"))) %>%
  mutate(DevelopmentClass = factor(DevelopmentClass, levels = c("Very Low", "Low", "Medium", "High", "Very High"))) %>%
  mutate(SurfaceAreaClass = factor(SurfaceAreaClass, levels = c("Very Small", "Small", "Medium", "Large")))

allBottom$Temp_anom <- NA
allBottom$DO_anom <- NA

# copy over bottom anomalies
for(i in 1:nrow(allBottom)) {
  pond <- allBottom$Station.name[i]
  if(allBottom$Depth[i] %% 1 != 0){
    a <- floor(allBottom$Depth[i]) + 0.01
    b <- ceiling(allBottom$Depth[i])
  } else {
    a <- allBottom$Depth[i]
    b <- allBottom$Depth[i]
  }
  allBottom$Temp_anom[i] <- allBottom$Temp[i] - clim_all$Temp[clim_all$Station.name == pond &
                                                              clim_all$Depth >= a &
                                                              clim_all$Depth <= b]
  allBottom$DO_anom[i] <- allBottom$DO[i] - clim_all$DO[clim_all$Station.name == pond &
                                                        clim_all$Depth >= a &
                                                        clim_all$Depth <= b]
}
```

```{r echo = FALSE}
selectInput("pond", label = "Choose sampling station:", choices = c("All ponds", pondName))

months <- ponds %>%
  group_by(Station.name, Date) %>%
  summarise(Month = Month[1])

renderPlot({
  if(input$pond != "All ponds") {
    hist(months$Month[months$Station.name == input$pond], right = FALSE,
         breaks = 1:12, ylim = c(0, 32),
         main = "Months of sampling events", col = "lightblue",
         xlab = "Month", ylab = "Total sampling events")
  } else {
    hist(months$Month, right = FALSE,
         breaks = 1:12,
         main = "Months of sampling events", col = "lightblue",
         xlab = "Month", ylab = "Total sampling events")
  }
})
```

### Surface nutrient levels

```{r echo = FALSE}
# max(allSurface$TN, na.rm = TRUE) # 5959.851
# max(allSurface$TP, na.rm = TRUE) # 416.29

sliderInput("xAxisMax", label = "X-axis maximum:", min = 0, max = 5600, value = 5600)
sliderInput("yAxisMax", label = "Y-axis maximum:", min = 0, max = 420, value = 420)

renderPlot({
  if(input$pond != "All ponds") {
    allSurface %>%
      filter(Station.name == input$pond) %>%
      filter(TN_flag == 2) %>%
      filter(TP_flag == 2) %>%
    ggplot(aes(x = TN, y = TP)) +
      geom_point(size = 2.5) +
      geom_abline(slope = 1/16, col = "black", linetype = "22", linewidth = 1) +
      scale_x_continuous(limits = c(0, input$xAxisMax)) +
      scale_y_continuous(limits = c(0, input$yAxisMax)) +
      labs(x = expression("TN (μg L"^-1*")"), y = expression("TP (μg L"^-1*")")) +
      theme_linedraw()
  } else {
    allSurface %>%
      filter(TN_flag == 2) %>%
      filter(TP_flag == 2) %>%
    ggplot(aes(x = TN, y = TP)) +
      geom_point(size = 2.5, alpha = 0.3) +
      geom_abline(slope = 1/16, col = "black", linetype = "22", linewidth = 1) +
      scale_x_continuous(limits = c(0, input$xAxisMax)) +
      scale_y_continuous(limits = c(0, input$yAxisMax)) +
      labs(x = expression("TN (μg L"^-1*")"), y = expression("TP (μg L"^-1*")")) +
      theme_linedraw()
  }
})
```

### Time-series analysis

#### Surface parameters

Note that choosing to show the Mann-Kendall trend will allow calculation of a trend for any parameter with 3+ measurements throughout time; thus not all of these trends will show up in the long-term trend plots below. (Those must meet the criteria of having at least 1 measurement in the first 25% of the data record, 1 in the last 25%, and a measurement in at least 50% of all years.)

```{r echo = FALSE}
# colnames(allSurface)[c(8:14, 16:18)] <- c("Secchi Depth (m)", "Temperature (°C)", "DO (mg/L)",
#                                           "DO_sat (%)", "Alkalinity (mg/L)", "TN (μg/L)",
#                                           "TN (μg/L)", "Chlorophyll-a (μg/L)")

start <- which(colnames(allSurface) == "Secchi")
end <- which(colnames(allSurface) == "Month") - 1

selectInput("param", label = "Choose parameter:", choices = colnames(allSurface)[start:end])
checkboxInput("MK2", "Show Mann-Kendall trend & Sen's slope?", value = FALSE)

renderPlot({
  if(input$pond != "All ponds") {
    flag_name <- paste0(input$param, "_flag")
    allSurface[allSurface$Station.name == input$pond &
               allSurface[[flag_name]] == 2, ] %>%
    ggplot(aes(x = Year, y = get(input$param))) +
      geom_point(size = 2.5) +
      labs(x = "Year", y = paste("Surface", input$param)) +
      theme_linedraw() +
      if(input$MK2) {
        mk <- mk.test(allSurface[[input$param]][allSurface$Station.name == input$pond &
                                                allSurface[[flag_name]] == 2])
        slope <- sens.slope(allSurface[[input$param]][allSurface$Station.name == input$pond &
                                            allSurface[[flag_name]] == 2])$estimates
        intercept <- median(allSurface[[input$param]][allSurface$Station.name == input$pond &
                                            allSurface[[flag_name]] == 2]) - 
                     median(allSurface$Year[allSurface$Station.name == input$pond &
                                            allSurface[[flag_name]] == 2]) * slope
        list(
          geom_abline(slope = slope, intercept = intercept, col = "black", linewidth = 1),
          annotate("text",
                   x = min(allSurface$Year[allSurface$Station.name == input$pond &
                                          allSurface[[flag_name]] == 2]) + 1,
                   y = max(allSurface[[input$param]][allSurface$Station.name == input$pond &
                                                allSurface[[flag_name]] == 2]) * 0.95,
                   label = paste("slope =", round(slope, 3)), col = "black"),
          annotate("text",
                   x = min(allSurface$Year[allSurface$Station.name == input$pond &
                                          allSurface[[flag_name]] == 2]) + 1,
                   y = max(allSurface[[input$param]][allSurface$Station.name == input$pond &
                                                    allSurface[[flag_name]] == 2]) * 0.92,
                   label = paste("p =", round(mk$p.value, 3)), col = "black")
        )
      }
  } else {
    flag_name <- paste0(input$param, "_flag")
    allSurface[allSurface[[flag_name]] == 2, ] %>%
    ggplot(aes(x = Year, y = get(input$param))) +
      geom_point(size = 2.5, alpha = 0.3) +
      labs(x = "Year", y = paste("Surface", input$param)) +
      theme_linedraw() +
      if(input$MK2) {
        annotate("text",
                   x = min(allSurface$Year[allSurface[[flag_name]] == 2]) + 2.5,
                   y = max(allSurface[[input$param]][allSurface[[flag_name]] == 2]) * 0.95,
                   label = "Must select individual\npond to calculate trend", col = "firebrick3")
      }
  }
})
```

#### Bottom parameters

```{r echo = FALSE}
start <- which(colnames(allBottom) == "MLD") + 1
end <- which(colnames(allBottom) == "Month") - 1

selectInput("param2", label = "Choose parameter:", choices = colnames(allBottom)[start:end])
checkboxInput("MK3", "Show Mann-Kendall trend & Sen's slope?", value = FALSE)

renderPlot({
  flag_name <- paste0(input$param2, "_flag")
  if(input$pond != "All ponds") {
    p <- allBottom[allBottom$Station.name == input$pond &
              allBottom[[flag_name]] == 2, ] %>%
    ggplot(aes(x = Year, y = get(input$param2))) +
      geom_point(size = 2.5) +
      labs(x = "Year", y = paste("Bottom", input$param2)) +
      theme_linedraw()
    if(input$param2 == "DO") {
      p <- p + geom_hline(yintercept = 3, col = "firebrick3", linewidth = 1)
    }
    if(input$MK3) {
      mk <- mk.test(allBottom[[input$param2]][allBottom$Station.name == input$pond &
                                              allBottom[[flag_name]] == 2])
      slope <- sens.slope(allBottom[[input$param2]][allBottom$Station.name == input$pond &
                                          allBottom[[flag_name]] == 2])$estimates
      intercept <- median(allBottom[[input$param2]][allBottom$Station.name == input$pond &
                                          allBottom[[flag_name]] == 2]) - 
                   median(allBottom$Year[allBottom$Station.name == input$pond &
                                          allBottom[[flag_name]] == 2]) * slope
      p <- p +
        geom_abline(slope = slope, intercept = intercept, col = "black", linewidth = 1) +
        annotate("text",
                 x = min(allBottom$Year[allBottom$Station.name == input$pond &
                                        allBottom[[flag_name]] == 2]) + 1,
                 y = max(allBottom[[input$param2]][allBottom$Station.name == input$pond &
                                              allBottom[[flag_name]] == 2]) * 0.95,
                 label = paste("slope =", round(slope, 3)), col = "black") +
        annotate("text",
                 x = min(allBottom$Year[allBottom$Station.name == input$pond &
                                        allBottom[[flag_name]] == 2]) + 1,
                 y = max(allBottom[[input$param2]][allBottom$Station.name == input$pond &
                                                  allBottom[[flag_name]] == 2]) * 0.92,
                 label = paste("p =", round(mk$p.value, 3)), col = "black")
    }
    p
  } else {
    p <- allBottom[allBottom[[flag_name]] == 2, ] %>%
    ggplot(aes(x = Year, y = get(input$param2))) +
      geom_point(size = 2.5, alpha = 0.3) +
      labs(x = "Year", y = paste("Bottom", input$param2)) +
      theme_linedraw()
    if(input$param2 == "DO") {
      p <- p + geom_hline(yintercept = 3, col = "firebrick3", linewidth = 1)
    }
    if(input$MK3) {
      p <- p +
        annotate("text",
                 x = min(allSurface$Year[allSurface[[flag_name]] == 2]) + 2.5,
                 y = max(allSurface[[input$param2]][allSurface[[flag_name]] == 2]) * 0.95,
                 label = "Must select individual\npond to calculate trend", col = "firebrick3")
    }
  p
  }
})
```

### Profile plots

```{r echo = FALSE}
renderPlot({
  p1 <- ponds[ponds$Station.name == input$pond, ] %>%
    ggplot(aes(x = Temp, y = Depth)) +
      geom_point(size = 2.5, shape = 21) +
      scale_y_reverse() +
      labs(y = "Depth (m)") +
      theme_linedraw() +
      theme(panel.grid = element_blank())
  p2 <- ponds[ponds$Station.name == input$pond, ] %>%
    ggplot(aes(x = DO, y = Depth)) +
      geom_point(size = 2.5, shape = 21) +
      scale_y_reverse() +
      labs(y = "Depth (m)") +
      theme_linedraw() +
      theme(panel.grid = element_blank())
  ggarrange(p1, p2, ncol = 2)
})

cols <- which(colnames(ponds) == "Max.Depth") : which(colnames(ponds) == "TP")

DT::renderDataTable({
  ponds[ponds$Station.name == input$pond, c(1, cols)] %>%
    rename(Date.Time = Date.Time..sampling.)
})
```

```{r echo = FALSE}
selectInput("param4", label = "Choose parameter:", choices = c("Temp", "DO"))
sliderInput("profile_range", label = "Choose year range:", min = 2001, max = 2023, value = c(2001, 2023))

renderPlot({
  flag_name <- paste0(input$param4, "_flag")
  ponds[ponds$Station.name == input$pond &
        (ponds[[flag_name]] == 2 |
          (ponds$Month != 8 &
           ponds$Month != 9 &
           !is.na(ponds[[input$param4]]))) &
        ponds$Year >= input$profile_range[1] &
        ponds$Year <= input$profile_range[2], ] %>%
  ggplot(aes(x = Year_frac, y = Depth, fill = get(input$param4))) +
    geom_point(size = 4, shape = 21) +
    scale_y_reverse() +
    scale_fill_gradientn(colors = parula(100), name = input$param4,
                         na.value = "white") +
    labs(x = "Year", y = "Depth (m)") +
    theme_linedraw() +
    theme(panel.grid = element_blank())
})
```

#### Anomaly plots

August and September averages.

```{r echo = FALSE}
renderPlot({
  anom_name <- paste0(input$param4, "_anom")
  flag_name <- paste0(input$param4, "_flag")
  min <- -max(abs(ponds[[anom_name]][ponds$Station.name == input$pond & ponds[[flag_name]] == 2]))
  max <- max(abs(ponds[[anom_name]][ponds$Station.name == input$pond & ponds[[flag_name]] == 2]))
  p1 <- clim_all[clim_all$Station.name == input$pond, ] %>%
  ggplot(aes(x = Station.name, y = Depth, fill = get(input$param4))) +
    geom_point(size = 4, shape = 21) +
    scale_y_reverse() +
    labs(y = "Depth (m)") +
    theme_linedraw() +
    theme(panel.grid = element_blank(),
          axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank()) +
    if(input$param4 == "Temp") {
      scale_fill_gradientn(colors = parula(100), name = input$param4,
                           limits = c(5, 28),
                           na.value = "white")
    } else if(input$param4 == "DO") {
      scale_fill_gradientn(colors = parula(100), name = input$param4,
                           limits = c(0, 15),
                           na.value = "white")
    }
  p2 <- ponds[ponds$Station.name == input$pond &
        ponds[[flag_name]] == 2, ] %>%
  ggplot(aes(x = Year_frac, y = Depth, fill = get(anom_name))) +
    geom_point(size = 4, shape = 21) +
    scale_y_reverse() +
    scale_fill_gradient2(low = "#3B4CC0", mid = "lightgrey", high = "#B40426",
                         midpoint = 0, name = anom_name,
                         limits = c(min, max), na.value = "white") +
    labs(x = "Year", y = "Depth (m)") +
    theme_linedraw() +
    theme(panel.grid = element_blank())
  ggarrange(p1, p2, widths = c(1, 10))
})

# note that this plot (below) currently includes data from all months

renderPlot({
  anom_name <- paste0(input$param4, "_anom")
  flag_name <- paste0(input$param4, "_flag")
  min <- -max(abs(ponds[[anom_name]][ponds$Station.name == input$pond & ponds[[flag_name]] == 2]))
  max <- max(abs(ponds[[anom_name]][ponds$Station.name == input$pond & ponds[[flag_name]] == 2]))
  ponds[ponds$Station.name == input$pond &
        ponds[[flag_name]] == 2, ] %>%
  ggplot(aes(x = get(anom_name), y = Depth, group = Date, col = Year)) +  # in case it breaks, 4/15 changed group to Date
    geom_path() +
    geom_point() +
    scale_x_continuous(limits = c(min, max), name = anom_name) +
    scale_y_reverse() +
    scale_color_gradientn(colors = plasma(100)) +
    labs(y = "Depth (m)") +
    theme_linedraw() +
    theme(panel.grid = element_blank())
})
```

```{r include = FALSE}
# create function for dealing with log10(0)
zero_sub <- function(x) {
  str <- strsplit(as.character(x), ".", fixed = TRUE)[[1]]
  if(str[1] != 0) {
    exp <- str_count(str[1], "0")
    return(10^exp)
  } else {
    exp <- str_count(str[2], "0") + 1
    return(10^-exp)
  }
}
```

### Regional patterns in surface data

```{r echo = FALSE}
props <- c("Secchi", "MLD", "Temp", "DO", "Alk", "TN", "TP", "Chla", "VerticalFishSpace", "VolumetricFishSpace")

selectInput("prop1", label = "Choose x parameter:", choices = props)

renderUI({
  props <- c("Secchi", "MLD", "Temp", "DO", "Alk", "TN", "TP", "Chla", "VerticalFishSpace", "VolumetricFishSpace")
  selectInput("prop2", label = "Choose y parameter:",
              choices = props[!(props %in% input$prop1)],
              selected = "Temp")
})

classes <- c("None", "Lens", "Depth", "Stratification", "Surface Area", "% Buffer Developed", "Nutrient Limitation")

sliderInput("yearRange", label = "Year range:", min = 2001, max = 2023, value = c(2001, 2023))
selectInput("class1", label = "Separate data by:", choices = classes)

renderUI({
  classes <- c("Lens", "Depth", "Stratification", "Surface Area", "% Buffer Developed", "Nutrient Limitation", "Year")
  selectInput("class2", label = "Color data by:",
              choices = classes[!(classes %in% input$class1)], selected = "Depth")
})

allSurface$None <- "None"

renderPlot({
  flag_name1 <- paste0(input$prop1, "_flag")
  flag_name2 <- paste0(input$prop2, "_flag")
  class1 <- case_when(input$class1 == "None" ~ "None",
                      input$class1 == "Depth" ~ "DepthClass",
                      input$class1 == "Stratification" ~ "StratClass",
                      input$class1 == "% Buffer Developed" ~ "DevelopmentClass",
                      input$class1 == "Surface Area" ~ "SurfaceAreaClass",
                      input$class1 == "Lens" ~ "Lens",
                      input$class1 == "Nutrient Limitation" ~ "NtPClass")
  class2 <- case_when(input$class2 == "Depth" ~ "DepthClass",
                      input$class2 == "Stratification" ~ "StratClass",
                      input$class2 == "% Buffer Developed" ~ "DevelopmentClass",
                      input$class2 == "Surface Area" ~ "SurfaceAreaClass",
                      input$class2 == "Lens" ~ "Lens",
                      input$class2 == "Nutrient Limitation" ~ "NtPClass",
                      input$class2 == "Year" ~ "Year")
  p <- allSurface[allSurface[[flag_name1]] == 2 &
             allSurface[[flag_name2]] == 2 &
             !is.na(allSurface[[class1]]) &
             !is.na(allSurface[[class2]]) &
             allSurface$Year >= input$yearRange[1] &
             allSurface$Year <= input$yearRange[2], ] %>%
  mutate(TN = if_else(TN == 0, zero_sub(sort(unique(allSurface$TN))[2]), TN),
         TP = if_else(TP == 0, zero_sub(sort(unique(allSurface$TP))[2]), TP),
         Chla = if_else(Chla == 0, zero_sub(sort(unique(allSurface$Chla))[2]), Chla)) %>%
  ggplot(aes(x = get(input$prop1), y = get(input$prop2), col = get(class2))) +
    geom_point(size = 2.5, shape = 1) +
    labs(x = input$prop1, y = input$prop2, col = input$class2) +
    theme_linedraw() +
    theme(panel.grid = element_blank())
    if(input$class1 != "None") {
      p <- p + facet_wrap(~ get(class1))
    }
    if(input$prop1 == "TP" | input$prop1 == "TN" | input$prop1 == "Chla") {
      p <- p + scale_x_log10()
    }
    if(input$prop2 == "TP" | input$prop2 == "TN" | input$prop2 == "Chla") {
      p <- p + scale_y_log10()
    }
    if(input$prop1 == "TP" & input$prop2 == "TN") {
      p <- p +
        scale_x_continuous() +
        scale_y_continuous() +
        geom_abline(slope = 16/1, col = "black", linetype = "22", linewidth = 1) +
        coord_trans(x = "log10", y = "log10")
    }
    if(input$prop1 == "TN" & input$prop2 == "TP") {
      p <- p +
        scale_x_continuous() +
        scale_y_continuous() +
        geom_abline(slope = 1/16, col = "black", linetype = "22", linewidth = 1) +
        coord_trans(x = "log10", y = "log10")
    }
  p
})
```

### Regional patterns in bottom data

```{r echo = FALSE}
props <- c("Secchi", "MLD", "Temp", "DO", "Alk", "TN", "TP", "VerticalFishSpace", "VolumetricFishSpace")

selectInput("prop3", label = "Choose x parameter:", choices = props)

renderUI({
  props <- c("Secchi", "MLD", "Temp", "DO", "Alk", "TN", "TP", "VerticalFishSpace", "VolumetricFishSpace")
  selectInput("prop4", label = "Choose y parameter:",
              choices = props[!(props %in% input$prop3)])
})

classes <- c("None", "Lens", "Stratification", "Surface Area", "% Buffer Developed", "Nutrient Limitation")

sliderInput("yearRange", label = "Year range:", min = 2001, max = 2023, value = c(2001, 2023))
selectInput("class3", label = "Separate data by:", choices = classes)

renderUI({
  classes <- c("Lens", "Stratification", "Surface Area", "% Buffer Developed", "Nutrient Limitation", "Year")
  selectInput("class4", label = "Color data by:",
              choices = classes[!(classes %in% input$class3)], selected = "Stratification")
})

allBottom$None <- "None"

renderPlot({
  flag_name1 <- paste0(input$prop3, "_flag")
  flag_name2 <- paste0(input$prop4, "_flag")
  class3 <- case_when(input$class3 == "None" ~ "None",
                      input$class3 == "Stratification" ~ "StratClass",
                      input$class3 == "% Buffer Developed" ~ "DevelopmentClass",
                      input$class3 == "Surface Area" ~ "SurfaceAreaClass",
                      input$class3 == "Lens" ~ "Lens",
                      input$class3 == "Nutrient Limitation" ~ "NtPClass")
  class4 <- case_when(input$class4 == "Stratification" ~ "StratClass",
                      input$class4 == "% Buffer Developed" ~ "DevelopmentClass",
                      input$class4 == "Surface Area" ~ "SurfaceAreaClass",
                      input$class4 == "Lens" ~ "Lens",
                      input$class4 == "Nutrient Limitation" ~ "NtPClass",
                      input$class4 == "Year" ~ "Year")
  p <- allBottom[allBottom[[flag_name1]] == 2 &
             allBottom[[flag_name2]] == 2 &
             !is.na(allBottom[[class3]]) &
             !is.na(allBottom[[class4]]) &
             allBottom$Year >= input$yearRange[1] &
             allBottom$Year <= input$yearRange[2], ] %>%
  mutate(TP = if_else(TP == 0, zero_sub(sort(unique(allBottom$TP))[2]), TP),
         TN = if_else(TN == 0, zero_sub(sort(unique(allBottom$TN))[2]), TN)) %>%
  ggplot(aes(x = get(input$prop3), y = get(input$prop4), col = get(class4))) +
    geom_point(size = 2.5, shape = 1) +
    labs(x = input$prop3, y = input$prop4, col = input$class4) +
    theme_linedraw() +
    theme(panel.grid = element_blank())
    if(input$class3 != "None") {
      p <- p + facet_wrap(~ get(class3))
    }
    if(input$prop3 == "TP" | input$prop3 == "TN") {
      p <- p + scale_x_log10()
    }
    if(input$prop4 == "TP" | input$prop4 == "TN") {
      p <- p + scale_y_log10()
    }
    if(input$prop3 == "TP" & input$prop4 == "TN") {
      p <- p +
        scale_x_continuous() +
        scale_y_continuous() +
        geom_abline(slope = 16/1, col = "black", linetype = "22", linewidth = 1) +
        coord_trans(x = "log10", y = "log10")
    }
    if(input$prop3 == "TN" & input$prop4 == "TP") {
      p <- p +
        scale_x_continuous() +
        scale_y_continuous() +
        geom_abline(slope = 1/16, col = "black", linetype = "22", linewidth = 1) +
        coord_trans(x = "log10", y = "log10")
    }
  p
})
```

### Cape Cod-wide maps

Most recent year of data from every pond:
```{r echo = FALSE}
# turn off spherical geometry to avoid "duplicate" errors
sf_use_s2(FALSE)

# get Massachusetts outline
mass <- read_sf("/Library/Frameworks/R.framework/Resources/gshhg-shp-2.3.7/GSHHS_shp/f/GSHHS_f_L1.shp") %>%
  st_make_valid() %>%
  st_crop(xmin = -71, xmax = -69, ymin = 41, ymax = 42.25)

# min(log10(surface_recent$NtP), na.rm = TRUE)
# max(log10(surface_recent$NtP), na.rm = TRUE)

renderPlot({
  surface_recent <- allSurface %>%
    group_by(Station.name) %>%
    filter(Year == max(Year)) %>%
    ungroup()
  ggplot() +
    geom_sf(data = mass) +
    geom_point(data = surface_recent[!is.na(surface_recent$TN_uM), ], aes(x = Long, y = Lat,
                                                                       col = log10(NtP)),
               size = 2.5) +
    scale_color_gradientn(colors = rev(parula(100)), name = "TN:TP", trans = "log10",
                          limits = c(1, 3.03), breaks = c(1, 2, 3), labels = c(10, 100, 1000)) +
    xlim(-70.65, -69.95) +
    ylim(41.55, 42.07) +
    theme_linedraw() +
    theme(axis.title = element_blank())
})
```

```{r echo = FALSE}
# Aug-Sept average of years 2016-2023:

# # min(log10(surface_recent$NtP), na.rm = TRUE)
# # max(log10(surface_recent$NtP), na.rm = TRUE)
# 
# renderPlot({
#   surface_recent <- allSurface %>%
#     filter(Year >= 2016) %>%
#     group_by(Station.name) %>%
#     summarise(across(where(is.numeric) & !Year, ~ mean(.x, na.rm = TRUE))) %>%
#       # ^don't average the actual years (e.g. 2016 + 2021)
#     mutate(across(where(is.numeric), ~ ifelse(is.nan(.), NA, .)))
#   ggplot() +
#     geom_sf(data = mass) +
#     geom_point(data = surface_recent[!is.na(surface_recent$TN_uM), ], aes(x = Long, y = Lat,
#                                                                        col = log10(TN_uM / TP_uM)),
#                size = 2.5) +
#     scale_color_gradientn(colors = rev(parula(100)), name = "TN:TP", trans = "log10",
#                           limits = c(1, 2.98), breaks = c(1, 2), labels = c(10, 100)) +
#     xlim(-70.65, -69.95) +
#     ylim(41.55, 42.07) +
#     theme_linedraw() +
#     theme(axis.title = element_blank())
# })
```

#### Mix and match
Aug-Sept average of years 2016-2023.

```{r echo = FALSE}
selectInput("layer", label = "Choose layer:", choices = c("Surface", "Bottom"))

renderUI({
  choices <- c("Secchi", "MLD", "Temp", "DO", "DO_sat", "Alk", "TN", "TP", "NtP", "Chla",
               "VerticalFishSpace", "VolumetricFishSpace")
  selectInput("param3", label = "Choose parameter:", choices = choices, selected = "Temp")
})

limits <- allSurface %>%
  mutate(layer = "s",
         Chla = NA) %>%
  rbind(cbind(allBottom, layer = "b")) %>%  # bind allS & allB
  filter(Year >= 2016) %>%
  group_by(Station.name, layer) %>%
  summarise(across(where(is.numeric) & !Year, ~ mean(.x, na.rm = TRUE))) %>%
  mutate(across(where(is.numeric), ~ ifelse(is.nan(.), NA, .)))

limits <- limits %>%
    mutate(TN = if_else(TN == 0, zero_sub(sort(unique(limits$TN))[2]), TN),
           TP = if_else(TP == 0, zero_sub(sort(unique(limits$TP))[2]), TP),
           Chla = if_else(Chla == 0, zero_sub(sort(unique(limits$Chla))[2]), Chla))

renderUI({
  val <- input$param3
  sliderInput("color", label = "Choose gradient limits:",
              min = ifelse(floor(min(limits[[val]], na.rm = TRUE)) == 0,
                           min(limits[[val]], na.rm = TRUE),
                           floor(min(limits[[val]], na.rm = TRUE))),
              max = ceiling(max(limits[[val]], na.rm = TRUE)),
              value = c(floor(min(limits[[val]], na.rm = TRUE)),
                        ceiling(max(limits[[val]], na.rm = TRUE))))
})

renderPlot({
  if(input$layer == "Surface") {
    data_recent <- allSurface %>%
      filter(Year >= 2016) %>%
      group_by(Station.name) %>%
      summarise(across(where(is.numeric) & !Year, ~ mean(.x, na.rm = TRUE))) %>%
        # ^don't average the actual years (e.g. 2016 + 2021)
      mutate(across(where(is.numeric), ~ ifelse(is.nan(.), NA, .))) %>%
      mutate(TN = if_else(TN == 0, zero_sub(sort(unique(limits$TN))[2]), TN),
             TP = if_else(TP == 0, zero_sub(sort(unique(limits$TP))[2]), TP),
             Chla = if_else(Chla == 0, zero_sub(sort(unique(limits$Chla))[2]), Chla))
  } else {
    data_recent <- allBottom %>%
      filter(Year >= 2016) %>%
      group_by(Station.name) %>%
      summarise(across(where(is.numeric) & !Year, ~ mean(.x, na.rm = TRUE))) %>%
      mutate(across(where(is.numeric), ~ ifelse(is.nan(.), NA, .))) %>%
      mutate(TN = if_else(TN == 0, zero_sub(sort(unique(limits$TN))[2]), TN),
             TP = if_else(TP == 0, zero_sub(sort(unique(limits$TP))[2]), TP))
  }
  p <- ggplot() +
    geom_sf(data = mass) +
    geom_point(data = data_recent[!is.na(data_recent[[input$param3]]), ],
                 aes(x = Long, y = Lat, col = get(input$param3)),
                 size = 2.5) +
    scale_color_gradientn(colors = parula(100), name = paste(input$layer, input$param3),
                          limits = c(input$color[1], input$color[2])) +
    xlim(-70.65, -69.95) +
    ylim(41.55, 42.07) +
    theme_linedraw() +
    theme(axis.title = element_blank()) +
    if(input$param3 == "TP" | input$param3 == "TN" | input$param3 == "Chla") {
      p <- p + scale_color_gradientn(colors = parula(100), name = paste(input$layer, input$param3),
                                     limits = c(input$color[1], input$color[2]), trans = "log10")
    }
    if(input$param3 == "NtP") {
      p <- p + scale_color_gradientn(colors = rev(parula(100)), name = paste(input$layer, input$param3),
                                     limits = c(input$color[1], input$color[2]), trans = "log10")
    }
  p
})
```

#### Regional patterns in anomalies

The region-wide anomaly values are visualized from a single year at a time.

```{r echo = FALSE}
selectInput("depth", label = "Choose layer:", choices = c("Surface", "Bottom"))
selectInput("param5", label = "Choose parameter:", choices = c("Temp", "DO"))
sliderInput("year", label = "Choose year:", min = 2001, max = 2023, value = 2001)

renderPlot({
  if(input$depth == "Surface") {
    one_depth <- allSurface
  } else {
    one_depth <- allBottom
  }
  anom_name <- paste0(input$param5, "_anom")
  flag_name <- paste0(input$param5, "_flag")
  min <- -max(abs(one_depth[[anom_name]][one_depth[[flag_name]] == 2]), na.rm = TRUE)
  max <- max(abs(one_depth[[anom_name]][one_depth[[flag_name]] == 2]), na.rm = TRUE)
  ggplot() +
    geom_sf(data = mass) +
    geom_point(data = one_depth[one_depth[[flag_name]] == 2 &
                                one_depth$Year == input$year, ],
               aes(x = Long, y = Lat, fill = get(anom_name), size = abs(get(anom_name))), shape = 21) +
    scale_fill_gradientn(colors = coolwarm(100), name = anom_name,
                         limits = c(min, max), na.value = "white") +
    scale_size_continuous(range = c(2, 6), name = paste(anom_name, "\nmagnitude"),
                          limits = c(0, max),
                          guide = "none") +
    xlim(-70.65, -69.95) +
    ylim(41.55, 42.07) +
    theme_linedraw() +
    theme(panel.grid = element_blank(),
          axis.title = element_blank())
})
```

```{r include = FALSE}
# calculate trends

focal_ponds <- ponds %>%
  filter(Month == 8 | Month == 9)

pondName <- sort(unique(focal_ponds$Station.name))

start <- which(colnames(allSurface) == "Secchi")
end <- which(colnames(allSurface) == "Chla")

slopes_surf <- data.frame(matrix(ncol = length(start:end) + 4, nrow = length(pondName)))
colnames(slopes_surf) <- c("pond", "Long", "Lat", "Last_year", colnames(allSurface)[start:end])

# add trend columns to allSurface for later use
for(param in colnames(allSurface)[start:end]) {
  allSurface[[paste0(param, "_trend_p")]] <- NA
}

for(i in 1:length(pondName)) {
  pond <- pondName[i]
  slopes_surf$pond[i] <- pond
  oneSurf <- allSurface[allSurface$Station.name == pond, ]
  # add noise to MLD values (not needed if no slopes of 0)
  #oneSurf$MLD <- oneSurf$MLD + runif(length(oneSurf$MLD), -0.01, 0.01)
  slopes_surf$Long[i] <- oneSurf$Long[1]
  slopes_surf$Lat[i] <- oneSurf$Lat[1]
  slopes_surf$Last_year[i] <- oneSurf$Last_year[1]
  if(nrow(oneSurf) < 3) {
    next
  }
  if(min(oneSurf$Year) > quantile(2001:2023)[2] |     # update this when years of data change
     max(oneSurf$Year) < quantile(2001:2023)[4]) {
    next
  }
  if(nrow(oneSurf) < (2023 - 2001)/2) {               # update this when years of data change
    next
  }
  for(param in colnames(allSurface)[start:end]) {
    if(sum(!is.na(oneSurf[[param]])) < 1) {
      next
    }
    if(min(oneSurf$Year[!is.na(oneSurf[[param]])]) > quantile(2001:2023)[2] |     # update this when years of data change
       max(oneSurf$Year[!is.na(oneSurf[[param]])]) < quantile(2001:2023)[4]) {
      next
    }
    if(nrow(oneSurf[!is.na(oneSurf[[param]]), ]) < (2023 - 2001)/2) {               # update this when years of data change
      next
    }
    if((param == "VerticalFishSpace" | param == "VolumetricFishSpace") &
       sum(oneSurf$VerticalFishSpace, na.rm = TRUE) == 0) {
      next
    }
    flag_name <- paste0(param, "_flag")
    mk <- mk.test(oneSurf[[param]][oneSurf[[flag_name]] == 2])
    if(mk$p.value >= 0.1) {
      next
    }
    slopes_surf[[param]][i] <- sens.slope(oneSurf[[param]][oneSurf[[flag_name]] == 2])$estimates
    allSurface[[paste0(param, "_trend_p")]][allSurface$Station.name == pond] <- mk$p.value
  }
}

## count trends
# slopes_surf <- slopes_surf %>%
#   rowwise() %>%
#   mutate(t = sum(!is.na(c(Secchi, MLD, Temp, DO, DO_sat, Alk, TN, TP, Chla))))

slopes_surf2 <- data.frame(matrix(ncol = length(start:end) + 4, nrow = length(pondName)))
colnames(slopes_surf2) <- c("pond", "Long", "Lat", "Last_year", colnames(allSurface)[start:end])

for(i in 1:length(pondName)) {
  pond <- pondName[i]
  slopes_surf2$pond[i] <- pond
  oneSurf <- allSurface[allSurface$Station.name == pond, ]
  # add noise to MLD values
  oneSurf$MLD <- oneSurf$MLD + runif(length(oneSurf$MLD), -0.01, 0.01)
  slopes_surf2$Long[i] <- oneSurf$Long[1]
  slopes_surf2$Lat[i] <- oneSurf$Lat[1]
  slopes_surf2$Last_year[i] <- oneSurf$Last_year[1]
  if(nrow(oneSurf) < 3) {
    next
  }
  if(min(oneSurf$Year) > quantile(2001:2023)[2] |     # update this when years of data change
     max(oneSurf$Year) < quantile(2001:2023)[4]) {
    next
  }
  if(nrow(oneSurf) < (2023 - 2001)/2) {               # update this when years of data change
    next
  }
  for(param in colnames(allSurface)[start:end]) {
    if(sum(!is.na(oneSurf[[param]])) < 1) {
      next
    }
    if(min(oneSurf$Year[!is.na(oneSurf[[param]])]) > quantile(2001:2023)[2] |     # update this when years of data change
       max(oneSurf$Year[!is.na(oneSurf[[param]])]) < quantile(2001:2023)[4]) {
      next
    }
    if(nrow(oneSurf[!is.na(oneSurf[[param]]), ]) < (2023 - 2001)/2) {               # update this when years of data change
      next
    }
    if((param == "VerticalFishSpace" | param == "VolumetricFishSpace") &
       sum(oneSurf$VerticalFishSpace, na.rm = TRUE) == 0) {
      next
    }
    flag_name <- paste0(param, "_flag")
    mk <- mk.test(oneSurf[[param]][oneSurf[[flag_name]] == 2])
    if(mk$p.value < 0.1) {
      next
    }
    slopes_surf2[[param]][i] <- sens.slope(oneSurf[[param]][oneSurf[[flag_name]] == 2])$estimates
    allSurface[[paste0(param, "_trend_p")]][allSurface$Station.name == pond] <- mk$p.value
  }
}

## count trends
# slopes_surf2 <- slopes_surf2 %>%
#   rowwise() %>%
#   mutate(t = sum(!is.na(c(Secchi, MLD, Temp, DO, DO_sat, Alk, TN, TP, Chla))))

start <- which(colnames(allBottom) == "Temp")
end <- which(colnames(allBottom) == "Chla") - 1

slopes_bott <- data.frame(matrix(ncol = length(start:end) + 4, nrow = length(pondName)))
colnames(slopes_bott) <- c("pond", "Long", "Lat", "Last_year", colnames(allBottom)[start:end])

# add trend columns to allBottom for later use
for(param in colnames(allBottom)[start:end]) {
  allBottom[[paste0(param, "_trend_p")]] <- NA
}

for(i in 1:length(pondName)) {
  pond <- pondName[i]
  slopes_bott$pond[i] <- pond
  oneBott <- allBottom[allBottom$Station.name == pond, ]
  slopes_bott$Long[i] <- oneBott$Long[1]
  slopes_bott$Lat[i] <- oneBott$Lat[1]
  slopes_bott$Last_year[i] <- oneBott$Last_year[1]
  if(nrow(oneBott) < 3) {
    next
  }
  if(min(oneBott$Year) > quantile(2001:2023)[2] |     # update this when years of data change
     max(oneBott$Year) < quantile(2001:2023)[4]) {
    next
  }
  if(nrow(oneBott) < (2023 - 2001)/2) {               # update this when years of data change
    next
  }
  for(param in colnames(allBottom)[start:end]) {
    if(sum(!is.na(oneBott[[param]])) < 1) {
      next
    }
    if(min(oneBott$Year[!is.na(oneBott[[param]])]) > quantile(2001:2023)[2] |     # update this when years of data change
       max(oneBott$Year[!is.na(oneBott[[param]])]) < quantile(2001:2023)[4]) {
      next
    }
    if(nrow(oneBott[!is.na(oneBott[[param]]), ]) < (2023 - 2001)/2) {               # update this when years of data change
      next
    }
    if((param == "VerticalFishSpace" | param == "VolumetricFishSpace") &
       sum(oneBott$VerticalFishSpace, na.rm = TRUE) == 0) {
      next
    }
    flag_name <- paste0(param, "_flag")
    mk <- mk.test(oneBott[[param]][oneBott[[flag_name]] == 2])
    if(mk$p.value >= 0.1) {
      next
    }
    slopes_bott[[param]][i] <- sens.slope(oneBott[[param]][oneBott[[flag_name]] == 2])$estimates
    allBottom[[paste0(param, "_trend_p")]][allBottom$Station.name == pond] <- mk$p.value
  }
}

slopes_bott2 <- data.frame(matrix(ncol = length(start:end) + 4, nrow = length(pondName)))
colnames(slopes_bott2) <- c("pond", "Long", "Lat", "Last_year", colnames(allBottom)[start:end])

for(i in 1:length(pondName)) {
  pond <- pondName[i]
  slopes_bott2$pond[i] <- pond
  oneBott <- allBottom[allBottom$Station.name == pond, ]
  slopes_bott2$Long[i] <- oneBott$Long[1]
  slopes_bott2$Lat[i] <- oneBott$Lat[1]
  slopes_bott2$Last_year[i] <- oneBott$Last_year[1]
  if(nrow(oneBott) < 3) {
    next
  }
  if(min(oneBott$Year) > quantile(2001:2023)[2] |     # update this when years of data change
     max(oneBott$Year) < quantile(2001:2023)[4]) {
    next
  }
  if(nrow(oneBott) < (2023 - 2001)/2) {               # update this when years of data change
    next
  }
  for(param in colnames(allBottom)[start:end]) {
    if(sum(!is.na(oneBott[[param]])) < 1) {
      next
    }
    if(min(oneBott$Year[!is.na(oneBott[[param]])]) > quantile(2001:2023)[2] |     # update this when years of data change
       max(oneBott$Year[!is.na(oneBott[[param]])]) < quantile(2001:2023)[4]) {
      next
    }
    if(nrow(oneBott[!is.na(oneBott[[param]]), ]) < (2023 - 2001)/2) {               # update this when years of data change
      next
    }
    if((param == "VerticalFishSpace" | param == "VolumetricFishSpace") &
       sum(oneBott$VerticalFishSpace, na.rm = TRUE) == 0) {
      next
    }
    flag_name <- paste0(param, "_flag")
    mk <- mk.test(oneBott[[param]][oneBott[[flag_name]] == 2])
    if(mk$p.value < 0.1) {
      next
    }
    slopes_bott2[[param]][i] <- sens.slope(oneBott[[param]][oneBott[[flag_name]] == 2])$estimates
    allBottom[[paste0(param, "_trend_p")]][allBottom$Station.name == pond] <- mk$p.value
  }
}
```

#### Surface trends over time

For a trend to be calculated, a given parameter in a given pond must meet the criteria of having at least 1 measurement in the first 25% of the data record, 1 in the last 25%, and a measurement in at least 50% of all years.

```{r echo = FALSE}
selectInput("param6", label = "Choose parameter:", choices = c("Secchi", "MLD", "Temp", "DO", "DO_sat", "Alk",
                                                               "TN", "TP", "NtP", "Chla",
                                                               "VerticalFishSpace", "VolumetricFishSpace"))

renderPlot({
  ggplot() +
    geom_sf(data = mass) +
    geom_point(data = slopes_surf2,
               aes(x = Long, y = Lat, size = abs(get(input$param6)), col = factor(sign(get(input$param6)))),
               shape = 21) +
    geom_point(data = slopes_surf,
               aes(x = Long, y = Lat, size = abs(get(input$param6)), fill = factor(sign(get(input$param6)))),
               shape = 21) +
    scale_size_continuous(range = c(2, 6), name = paste(input$param6, "trend\nmagnitude")) +
    scale_fill_manual(values = c("royalblue", "black", "firebrick"),
                      breaks = c(-1, 0, 1),
                      limits = factor(c(-1, 0, 1)),
                      labels = c("negative", "zero", "positive"),
                      name = paste(input$param6, "trend\ndirection"),
                      na.translate = FALSE) +
    scale_color_manual(values = c("royalblue", "black", "firebrick"),
                       breaks = c(-1, 0, 1),
                       limits = factor(c(-1, 0, 1)),
                       labels = c("negative", "zero", "positive"),
                       name = paste(input$param6, "trend\ndirection"),
                       na.translate = FALSE) +
    xlim(-70.65, -69.95) +
    ylim(41.55, 42.07) +
    theme_linedraw() +
    theme(panel.grid = element_blank(),
          axis.title = element_blank()) +
    guides(fill = guide_legend(order = 1),
           col = guide_legend(order = 1))
})
```

#### Bottom trends over time

```{r echo = FALSE}
selectInput("param7", label = "Choose parameter:", choices = c("Temp", "DO", "DO_sat", "Alk",
                                                               "TN", "TP", "NtP"))

renderPlot({
  ggplot() +
    geom_sf(data = mass) +
    geom_point(data = slopes_bott2,
               aes(x = Long, y = Lat, size = abs(get(input$param7)), col = factor(sign(get(input$param7)))),
               shape = 21) +
    geom_point(data = slopes_bott,
               aes(x = Long, y = Lat, size = abs(get(input$param7)), fill = factor(sign(get(input$param7)))),
               shape = 21) +
    scale_size_continuous(range = c(2, 6), name = paste(input$param7, "trend\nmagnitude")) +
    scale_fill_manual(values = c("royalblue", "black", "firebrick"), 
                      breaks = c(-1, 0, 1),
                      limits = factor(c(-1, 0, 1)),
                      labels = c("negative", "zero", "positive"),
                      name = paste(input$param7, "trend\ndirection"),
                      na.translate = FALSE) +
    scale_color_manual(values = c("royalblue", "black", "firebrick"),
                       breaks = c(-1, 0, 1),
                       limits = factor(c(-1, 0, 1)),
                       labels = c("negative", "zero", "positive"),
                       name = paste(input$param7, "trend\ndirection"),
                       na.translate = FALSE) +
    xlim(-70.65, -69.95) +
    ylim(41.55, 42.07) +
    theme_linedraw() +
    theme(panel.grid = element_blank(),
          axis.title = element_blank()) +
    guides(fill = guide_legend(order = 1),
           col = guide_legend(order = 1))
})
```

#### Regional trends in trends ;)

```{r echo = FALSE}
selectInput("layer2", label = "Choose layer:", choices = c("Surface", "Bottom"))

renderUI({
  choices <- c("Secchi", "MLD", "Temp", "DO", "DO_sat", "Alk", "TN", "TP", "NtP", "Chla")
  selectInput("trend", label = "Choose parameter:", choices = choices, selected = choices[1])
})

lensRKTs <- data.frame(matrix(nrow = 5, ncol = 8))
rownames(lensRKTs) <- c("tau", "S", "varS", "p-value", "slope")

DT::renderDataTable({
  if(input$layer2 == "Surface") {
    trend_data <- allSurface %>%
      filter(!is.na(get(paste0(input$trend, "_trend_p")))) %>%  # remove observations from "non-continuous" ponds
      # jitter MLD values (noise prevents slopes of 0)
      mutate(MLD = MLD + runif(length(MLD), -0.05, 0.05))
  } else {
    trend_data <- allBottom %>%
      filter(!is.na(get(paste0(input$trend, "_trend_p"))))  # remove observations from "non-continuous" ponds
  }
  flag_name <- paste0(input$trend, "_flag")
  for(i in 1:length(unique(ponds$Lens[!is.na(ponds$Lens)]))) {
    lens <- sort(unique(ponds$Lens[!is.na(ponds$Lens)]))[i]
    colnames(lensRKTs)[i] <- lens
    
    if(length(trend_data$Year_frac[trend_data[[flag_name]] == 2 &
                                   !is.na(trend_data$Lens) &
                                   trend_data$Lens == lens]) < 4) {
      next
    }
    rk <- rkt(trend_data$Year_frac[trend_data[[flag_name]] == 2 &
                                     !is.na(trend_data$Lens) & trend_data$Lens == lens],
              trend_data[[input$trend]][trend_data[[flag_name]] == 2 & !is.na(trend_data$Lens) &
                                          trend_data$Lens == lens],
              as.numeric(factor(trend_data$Station.name[trend_data[[flag_name]] == 2 & 
                                                          !is.na(trend_data$Lens) & trend_data$Lens == lens])),
              rep = "a")
    lensRKTs[1:5, i] <- round(unlist(rk[c(12, 2, 4, 1, 3)]), c(3, 0, 0, 3, 3))
  }
  colnames(lensRKTs)[8] <- "Cape-wide"
  rk <- rkt(trend_data$Year_frac[trend_data[[flag_name]] == 2],
            trend_data[[input$trend]][trend_data[[flag_name]] == 2],
            as.numeric(factor(trend_data$Station.name[trend_data[[flag_name]] == 2])),
            rep = "a")
  lensRKTs[1:5, 8] <- round(unlist(rk[c(12, 2, 4, 1, 3)]), c(3, 0, 0, 3, 3))
  datatable(lensRKTs,
            options = list(dom = "t",
                           ordering = FALSE)) %>%
    formatStyle(0, fontWeight = "bold")
})
```

#### Regional patterns in trends, continued

```{r echo = FALSE}
selectInput("layer3", label = "Choose layer:", choices = c("Surface", "Bottom"))
selectInput("prop5", label = "Choose x parameter:", choices = c("Secchi", "MLD", "Temp", "DO", "Alk",
                                                                "TN", "TP", "NtP", "Chla"))

for(i in 1:nrow(slopes_surf)) {
  ID <- slopes_surf$pond[i]
  slopes_surf$DepthClass[i] <- ponds$DepthClass[which.max(ponds$Station.name == ID)]
  slopes_surf$DevelopmentClass[i] <- ponds$DevelopmentClass[which.max(ponds$Station.name == ID)]
  slopes_surf$SurfaceAreaClass[i] <- ponds$SurfaceAreaClass[which.max(ponds$Station.name == ID)]
  slopes_surf$Lens[i] <- ponds$Lens[which.max(ponds$Station.name == ID)]
}

for(i in 1:nrow(slopes_surf2)) {
  ID <- slopes_surf2$pond[i]
  slopes_surf2$DepthClass[i] <- ponds$DepthClass[which.max(ponds$Station.name == ID)]
  slopes_surf2$DevelopmentClass[i] <- ponds$DevelopmentClass[which.max(ponds$Station.name == ID)]
  slopes_surf2$SurfaceAreaClass[i] <- ponds$SurfaceAreaClass[which.max(ponds$Station.name == ID)]
  slopes_surf2$Lens[i] <- ponds$Lens[which.max(ponds$Station.name == ID)]
}

for(i in 1:nrow(slopes_bott)) {
  ID <- slopes_bott$pond[i]
  slopes_bott$DepthClass[i] <- ponds$DepthClass[which.max(ponds$Station.name == ID)]
  slopes_bott$DevelopmentClass[i] <- ponds$DevelopmentClass[which.max(ponds$Station.name == ID)]
  slopes_bott$SurfaceAreaClass[i] <- ponds$SurfaceAreaClass[which.max(ponds$Station.name == ID)]
  slopes_bott$Lens[i] <- ponds$Lens[which.max(ponds$Station.name == ID)]
}

for(i in 1:nrow(slopes_bott2)) {
  ID <- slopes_bott2$pond[i]
  slopes_bott2$DepthClass[i] <- ponds$DepthClass[which.max(ponds$Station.name == ID)]
  slopes_bott2$DevelopmentClass[i] <- ponds$DevelopmentClass[which.max(ponds$Station.name == ID)]
  slopes_bott2$SurfaceAreaClass[i] <- ponds$SurfaceAreaClass[which.max(ponds$Station.name == ID)]
  slopes_bott2$Lens[i] <- ponds$Lens[which.max(ponds$Station.name == ID)]
}

slopes_surf$sig <- "S"
slopes_surf2$sig <- "NS"
slopes_bott$sig <- "S"
slopes_bott2$sig <- "NS"
```

#### Significant trends only

```{r echo = FALSE}
renderPlot({
  if(input$layer3 == "Surface") {
    layer_data <- slopes_surf %>%
      mutate(DepthClass = factor(DepthClass, levels = c("Shallow", "Deep"))) %>%
      mutate(DevelopmentClass = factor(DevelopmentClass, levels = c("Very Low", "Low", "Medium", "High", "Very High"))) %>%
      mutate(SurfaceAreaClass = factor(SurfaceAreaClass, levels = c("Very Small", "Small", "Medium", "Large")))
  } else {
    layer_data <- slopes_bott %>%
      mutate(DepthClass = factor(DepthClass, levels = c("Shallow", "Deep"))) %>%
      mutate(DevelopmentClass = factor(DevelopmentClass, levels = c("Very Low", "Low", "Medium", "High", "Very High"))) %>%
      mutate(SurfaceAreaClass = factor(SurfaceAreaClass, levels = c("Very Small", "Small", "Medium", "Large")))
  }
  d <- ggplot(layer_data[!is.na(layer_data$DepthClass), ],
              aes(x = get(input$prop5), fill = DepthClass)) +
    geom_histogram(binwidth = max(layer_data[[input$prop5]], na.rm = TRUE) / 10) +
    labs(x = paste(input$prop5, "trend (slope)")) +
    theme_linedraw() +
    theme(panel.grid = element_blank()) +
    guides(fill = guide_legend(order = 1))
  b <- ggplot(layer_data[!is.na(layer_data$DevelopmentClass), ],
              aes(x = get(input$prop5), fill = DevelopmentClass)) +
    geom_histogram(binwidth = max(layer_data[[input$prop5]], na.rm = TRUE) / 10) +
    labs(x = paste(input$prop5, "trend (slope)")) +
    theme_linedraw() +
    theme(panel.grid = element_blank()) +
    guides(fill = guide_legend(order = 1))
  s <- ggplot(layer_data[!is.na(layer_data$SurfaceAreaClass), ],
              aes(x = get(input$prop5), fill = SurfaceAreaClass)) +
    geom_histogram(binwidth = max(layer_data[[input$prop5]], na.rm = TRUE) / 10) +
    labs(x = paste(input$prop5, "trend (slope)")) +
    theme_linedraw() +
    theme(panel.grid = element_blank()) +
    guides(fill = guide_legend(order = 1))
  l <- ggplot(layer_data[!is.na(layer_data$Lens), ],
              aes(x = get(input$prop5), fill = Lens)) +
    geom_histogram(binwidth = max(layer_data[[input$prop5]], na.rm = TRUE) / 10) +
    labs(x = paste(input$prop5, "trend (slope)")) +
    theme_linedraw() +
    theme(panel.grid = element_blank()) +
    guides(fill = guide_legend(order = 1))
  ggarrange(d, b, s, l, ncol = 2)
})
```

#### All trends

```{r echo = FALSE}
renderPlot({
  if(input$layer3 == "Surface") {
    layer_data <- bind_rows(slopes_surf, slopes_surf2) %>%
      mutate(DepthClass = factor(DepthClass, levels = c("Shallow", "Deep"))) %>%
      mutate(DevelopmentClass = factor(DevelopmentClass, levels = c("Very Low", "Low", "Medium", "High", "Very High"))) %>%
      mutate(SurfaceAreaClass = factor(SurfaceAreaClass, levels = c("Very Small", "Small", "Medium", "Large"))) %>%
      mutate(sig = factor(sig, levels = c("S", "NS")))
  } else {
    layer_data <- bind_rows(slopes_bott, slopes_bott2) %>%
      mutate(DepthClass = factor(DepthClass, levels = c("Shallow", "Deep"))) %>%
      mutate(DevelopmentClass = factor(DevelopmentClass, levels = c("Very Low", "Low", "Medium", "High", "Very High"))) %>%
      mutate(SurfaceAreaClass = factor(SurfaceAreaClass, levels = c("Very Small", "Small", "Medium", "Large"))) %>%
      mutate(sig = factor(sig, levels = c("S", "NS")))
  }
  d <- ggplot(layer_data[!is.na(layer_data$DepthClass), ],
              aes(x = get(input$prop5), fill = DepthClass, alpha = sig)) +
    geom_histogram(binwidth = max(layer_data[[input$prop5]], na.rm = TRUE) / 10) +
    scale_alpha_manual(values = c(1, 0.5), name = "Significance") +
    labs(x = paste(input$prop5, "trend (slope)")) +
    theme_linedraw() +
    theme(panel.grid = element_blank()) +
    guides(fill = guide_legend(order = 1))
  b <- ggplot(layer_data[!is.na(layer_data$DevelopmentClass), ],
              aes(x = get(input$prop5), fill = DevelopmentClass, alpha = sig)) +
    geom_histogram(binwidth = max(layer_data[[input$prop5]], na.rm = TRUE) / 10) +
    scale_alpha_manual(values = c(1, 0.5), name = "Significance", guide = "none") +
    labs(x = paste(input$prop5, "trend (slope)")) +
    theme_linedraw() +
    theme(panel.grid = element_blank()) +
    guides(fill = guide_legend(order = 1))
  s <- ggplot(layer_data[!is.na(layer_data$SurfaceAreaClass), ],
              aes(x = get(input$prop5), fill = SurfaceAreaClass, alpha = sig)) +
    geom_histogram(binwidth = max(layer_data[[input$prop5]], na.rm = TRUE) / 10) +
    scale_alpha_manual(values = c(1, 0.5), name = "Significance", guide = "none") +
    labs(x = paste(input$prop5, "trend (slope)")) +
    theme_linedraw() +
    theme(panel.grid = element_blank()) +
    guides(fill = guide_legend(order = 1))
  l <- ggplot(layer_data[!is.na(layer_data$Lens), ],
              aes(x = get(input$prop5), fill = Lens, alpha = sig)) +
    geom_histogram(binwidth = max(layer_data[[input$prop5]], na.rm = TRUE) / 10) +
    scale_alpha_manual(values = c(1, 0.5), name = "Significance", guide = "none") +
    labs(x = paste(input$prop5, "trend (slope)")) +
    theme_linedraw() +
    theme(panel.grid = element_blank()) +
    guides(fill = guide_legend(order = 1))
  ggarrange(d, b, s, l, ncol = 2)
})
```

```{r include = FALSE}
reg_surf <- data.frame(matrix(ncol = 4, nrow = length(pondName)))
colnames(reg_surf) <- c("pond", "Long", "Lat", "mean_DO")

for(i in 1:length(pondName)) {
  pond <- pondName[i]
  reg_surf$pond[i] <- pond
  oneSurf <- allSurface[allSurface$Station.name == pond, ]
  reg_surf$Long[i] <- oneSurf$Long[1]
  reg_surf$Lat[i] <- oneSurf$Lat[1]
  reg_surf$mean_DO[i] <- clim_all$DO[clim_all$Station.name == pond &
                                     clim_all$Depth == min(clim_all$Depth[clim_all$Station.name == pond])]
}

reg_surf$lim <- reg_surf$mean_DO / 3

slopes_surf$DO_lim <- reg_surf$lim[reg_surf$pond == slopes_surf$pond]
slopes_surf2$DO_lim <- reg_surf$lim[reg_surf$pond == slopes_surf2$pond]

reg_bott <- data.frame(matrix(ncol = 4, nrow = length(pondName)))
colnames(reg_bott) <- c("pond", "Long", "Lat", "mean_DO")

for(i in 1:length(pondName)) {
  pond <- pondName[i]
  reg_bott$pond[i] <- pond
  oneBott <- allBottom[allBottom$Station.name == pond, ]
  reg_bott$Long[i] <- oneBott$Long[1]
  reg_bott$Lat[i] <- oneBott$Lat[1]
  reg_bott$mean_DO[i] <- clim_all$DO[clim_all$Station.name == pond &
                                     clim_all$Depth == max(clim_all$Depth[clim_all$Station.name == pond])]
}

reg_bott$lim <- reg_bott$mean_DO / 3

slopes_bott$DO_lim <- reg_bott$lim[reg_bott$pond == slopes_bott$pond]
slopes_bott2$DO_lim <- reg_bott$lim[reg_bott$pond == slopes_bott2$pond]
```

#### DO proportion of regulatory limit
```{r echo = FALSE}
## change point outline thickness

selectInput("layer4", label = "Choose layer:", choices = c("Surface", "Bottom"))

renderPlot({
  if(input$layer4 == "Surface") {
    slopes <- slopes_surf
    slopes2 <- slopes_surf2
  } else {
    slopes <- slopes_bott
    slopes2 <- slopes_bott2
  }
  ggplot() +
    geom_sf(data = mass, fill = "white") +
    geom_point(data = slopes,
               aes(x = Long, y = Lat, size = abs(DO), fill = DO_lim, col = factor(sign(DO))),
               shape = 23, stroke = 2) +
    geom_point(data = slopes2,
               aes(x = Long, y = Lat, size = abs(DO), fill = DO_lim, col = factor(sign(DO))),
               shape = 23, stroke = 2, alpha = 0.5) +
    scale_size_continuous(range = c(2, 6), name = "DO trend\nmagnitude") +
    scale_fill_gradientn(colors = kovesi.diverging_cwm_80_100_c22(100),
                         limits = c(0, 6),
                         name = "Mean DO value",
                         na.value = "#FAAEF0") +
    scale_color_manual(values = c("royalblue", "black", "firebrick"),
                          breaks = c(-1, 0, 1),
                          labels = c("negative", "zero", "positive"),
                          name = "DO trend\ndirection") +
    # scale_shape_manual(values = c(25, 21, 24),
    #                    breaks = c(-1, 0, 1),
    #                    labels = c("negative", "zero", "positive"),
    #                    name = "DO trend\ndirection") +
    xlim(-70.65, -69.95) +
    ylim(41.55, 42.07) +
    theme_linedraw() +
    theme(panel.grid = element_blank(),
          axis.title = element_blank())
})
```
